// Fundamentos do Desenvolvimento Web

// Bloco 9.1 - JavaScript AssÃ­ncrono e Promises:
// JavaScript AssÃ­ncrono e Callbacks

// O que vamos aprender?

// Numa lÃ³gica normal, sequencial de programaÃ§Ã£o, sua pÃ¡gina esperaria o serviÃ§o dar retorno ou voltar ao ar para continuar. Ou seja, a pÃ¡gina ficaria quebrada, ou teria todo o seu carregamento freado em funÃ§Ã£o de um problema totalmente fora do seu controle. Para lidar com esse problema e outros de natureza similar, existe um conceito que Ã© muito poderoso e presente no JavaScript : a assincronicidade. Em vez de o programa ser carregado todo em sequÃªncia, uma linha apÃ³s a outra, linhas que podem trazer esse tipo de problema podem "ficar carregando", enquanto o resto do seu programa executa normalmente. A execuÃ§Ã£o dessa linha, a espera pela disponibilidade desse serviÃ§o, corre paralelamente ao desenvolver do restante do cÃ³digo. Ã‰ uma execuÃ§Ã£o assÃ­ncrona. E isso tem muito poder. 

// conceitos importantes:
// OperaÃ§Ãµes assÃ­ncronas;
// callbacks.

// VocÃª serÃ¡ capaz de:
// Aplicar corretamente operaÃ§Ãµes assÃ­ncronas;
// Utilizar callbacks corretamente.

// Por que isso Ã© importante?
// AtÃ© entÃ£o, vocÃª tem programado de uma forma basicamente similar Ã  seguinte:
// Execute o passo A;
// Execute o passo B;
// Execute o passo C.

// Suponha que vocÃª tenha uma operaÃ§Ã£o A que gaste muito tempo, e que vocÃª tenha uma operaÃ§Ã£o B em sequÃªncia que independe totalmente de A. B ter que esperar por A Ã© um problema, haja vista que B nÃ£o depende de forma alguma de A. Como vocÃª faz para contornar esse problema?

// Resposta: assincronicidade

// Com assincronicidade, a operaÃ§Ã£o A comeÃ§a a executar e, logo em seguida, B tambÃ©m, sem ter que esperar A terminar.


// ConteÃºdos --------------------------------------------------------------------------------
- OperaÃ§Ãµes - assÃ­ncronas ;

// OperaÃ§Ãµes em JavaScript sÃ£o tradicionalmente sÃ­ncronas, ou seja, para que uma cadeia de operaÃ§Ãµes seja realizada, Ã© necessÃ¡rio que uma operaÃ§Ã£o termine para que outra comece. Em uma linha de produÃ§Ã£o de automÃ³veis por exemplo, vÃ¡rias etapas de produÃ§Ã£o sÃ£o codependentes. Podemos relacionar estas etapas de produÃ§Ã£o Ã s operaÃ§Ãµes sÃ­ncronas em JavaScript. Observe o exemplo abaixo para que esta analogia fique mais clara:
console.log('1 - Receber roda');
console.log('2 - Encaixar parafusos');
console.log('3 - Fixar roda no carro');

// Observe que estamos trabalhando de forma ineficiente e adicionando etapas desnecessÃ¡rias Ã  nossa produÃ§Ã£o pois se tivermos parafusos suficientes em estoque, nÃ£o precisamos parar a montagem para que mais parafusos sejam comprados e repostos. Assim como na nossa linha de produÃ§Ã£o, existem operaÃ§Ãµes que nÃ£o possuem esta codependÃªncia em JavaScript, e com objetivo de cobrir justamente este tipo de situaÃ§Ã£o surgem as operaÃ§Ãµes assÃ­ncronas.
setTimeout(() => {
    console.log('Comprar parafusos') // Comprar parafusos
    console.log('Adicionar ao estoque') // Adicionar ao estoque
  }, 2000);
  
  console.log('1 - Receber roda'); // 1 - Receber roda
  console.log('2 - Encaixar parafusos'); // 2 - Encaixar parafusos
  console.log('3 - Fixar roda no carro'); // 3 - Fixar roda no carro

// Note que console.log('Comprar parafusos') e console.log('Adicionar ao estoque') foram declarados antes das etapas 1, 2 e 3, mesmo assim o retorno das chamadas sÃ³ ocorre ao final. Isto acontece pois utilizamos a funÃ§Ã£o setTimeout. Ã‰ muito comum que esta funÃ§Ã£o seja utilizada para simular comportamentos assÃ­ncronos. Na prÃ¡tica vivenciaremos situaÃ§Ãµes em que nossa aplicaÃ§Ã£o depende de uma informaÃ§Ã£o externa, como por exemplo, solicitar uma informaÃ§Ã£o a um banco de dados. Ã‰ aÃ­ que o conceito de assincronicidade entra a nosso favor para que nossa aplicaÃ§Ã£o nÃ£o perca eficiÃªncia.
const assert = require('assert');
const pushNumber = (list, number) => list.push(number);
let numbers = [];

pushNumber(numbers, 1);
pushNumber(numbers, 2);
pushNumber(numbers, 3);

assert.deepStrictEqual(numbers, [1, 2, 3]);

// --------------------------
const assert = require('assert');
const pushNumber = (list, number) => list.push(number);
let numbers = [];

setTimeout(() => pushNumber(numbers, 1), 3000);
pushNumber(numbers, 2);
pushNumber(numbers, 3);

assert.deepStrictEqual(numbers, [1, 2, 3]); // essa validaÃ§Ã£o falha

// Por que a validaÃ§Ã£o referente ao primeiro cÃ³digo funciona, e a referente ao segundo nÃ£o? O teste espera receber o array [1, 2, 3] , mas apenas recebe o [2, 3]. Isso ocorre por causa da funÃ§Ã£o setTimeout. Ela Ã© uma funÃ§Ã£o assÃ­ncrona, que espera alguns milissegundos para executar a funÃ§Ã£o passada a ela como parÃ¢metro. No cÃ³digo acima, ela espera 3000 milissegundos (3 segundos) para executar o pushNumber(numbers, 1).

// Para passar no teste, Ã© necessÃ¡rio testar o numbers apÃ³s 3000 milissegundos:
const assert = require('assert');
const pushNumber = (list, number) => {
  list.push(number);
  console.log(list);
};

let numbers = [];
setTimeout(() => pushNumber(numbers, 1), 3000);
pushNumber(numbers, 2);
pushNumber(numbers, 3);

setTimeout(() => assert.deepStrictEqual(numbers, [2, 3, 1]), 3000);

// Observe que, alÃ©m de adicionar o setTimeout, o array [1, 2, 3] foi modificado para [2, 3, 1]. Isso se dÃ¡, pois, como a funÃ§Ã£o Ã© assÃ­ncrona, o cÃ³digo continua rodando, mesmo que ela ainda nÃ£o tenha terminado de executar. Ou seja, o array recebe primeiro o 2, depois o 3, e apÃ³s os 3 segundos do setTimeout, ele recebe o 1.

// https://www.w3schools.com/jsref/met_win_settimeout.asp

// ConteÃºdos --------------------------------------------------------------------------------
Callbacks;

// callback Ã© uma funÃ§Ã£o passada como parÃ¢metro para outra funÃ§Ã£o. Sem perceber vocÃª viu um exemplo de funÃ§Ã£o callback quando chamamos a funÃ§Ã£o setTimeout. Esta funÃ§Ã£o recebe dois parÃ¢metros, o primeiro Ã© a funÃ§Ã£o callback que passamos atravÃ©s de uma arrow function , e o segundo Ã© o tempo que o interpretador irÃ¡ esperar para executar a funÃ§Ã£o.
const myExpenses = [
  {
    gym: 99,
  },
  {
    ifood: 200,
  },
  {
    phone: 60,
  },
  {
    internet: 100,
  },
];

const myIncome = 1000;

// Neste primeiro trecho de cÃ³digo temos duas declaraÃ§Ãµes de variÃ¡veis. A primeira delas myExpenses, Ã© um array de objetos que representa os gastos de uma pessoa no mÃªs. A segunda, myIncome, representa o quanto esta pessoa recebeu neste mesmo mÃªs.

// Nosso prÃ³ximo passo serÃ¡ implementar uma funÃ§Ã£o que trate estas informaÃ§Ãµes para que tenhamos como resultado um balanÃ§o de entradas e saÃ­das do mÃªs.
const monthlyBudget = (myIncome, myExpenses, callback) => {

  const totalExpenses = callback(myExpenses);
  const totalAfterExpenses = myIncome - totalExpenses;

  console.log(`BalanÃ§o do mÃªs:
    Recebido: R$${myIncome},00
    Gasto: R$${totalExpenses},00
    Saldo: R$${totalAfterExpenses},00 `);
};

// Neste trecho da implementaÃ§Ã£o podemos notar que foi adicionada uma funÃ§Ã£o monthlyBudget que recebe trÃªs parÃ¢metros, myIncome, myExpenses, e callback. Acredito que vocÃª deve estar pensando, "O que este parÃ¢metro callback estÃ¡ fazendo nesta funÃ§Ã£o?".

// Como vimos anteriormente, callback Ã© basicamente uma funÃ§Ã£o passada por parÃ¢metro para outra funÃ§Ã£o. Neste exemplo o parÃ¢metro callback receberÃ¡ uma funÃ§Ã£o que retornarÃ¡ o quanto gastamos no mÃªs, ou seja, nossa funÃ§Ã£o callback irÃ¡ realizar a lÃ³gica necessÃ¡ria para somar todos os gastos contidos no array de objetos myExpenses, e retornarÃ¡ este valor para a constante totalExpenses.
const handleExpenses = myExpenses => {
  const eachValue = myExpenses.map((item) => Object.values(item)[0]);
  const totalExpense = eachValue.reduce((acc, curr) => acc + curr , 0);
  return totalExpense;
};

monthlyBudget(myIncome, myExpenses, handleExpenses);

// Por fim podemos observar a implementaÃ§Ã£o da nossa funÃ§Ã£o callback representada pela funÃ§Ã£o handleExpenses. Esta funÃ§Ã£o estÃ¡ tratando as informaÃ§Ãµes contidas no array de objetos myExpenses e retornando o valor total de gastos.

// Em sÃ­ntese o que fizemos foi:
// - Criamos variÃ¡veis que representam o quanto recebemos no mÃªs e o quanto gastamos no mÃªs.
// - Implementamos a funÃ§Ã£o monthlyBudget que recebe trÃªs parÃ¢metros, nossos gastos, nossa renda e a funÃ§Ã£o callback.
// - Realizamos a implementaÃ§Ã£o da funÃ§Ã£o callback representada por handleExpenses que recebe nossos gastos mensais e retorna um valor de gastos total.
// - Adicionamos handleExpenses na chamada da funÃ§Ã£o monthlyBudget e como resultado temos o balanÃ§o mensal.
const myExpenses = [
  {
    gym: 99,
  },
  {
    ifood: 200,
  },
  {
    phone: 60,
  },
  {
    internet: 100,
  },
];

const myIncome = 1000;
const monthlyBudget = (myIncome, myExpenses, callback) => {
  const totalExpenses = callback(myExpenses);
  const totalAfterExpenses = myIncome - totalExpenses;
  console.log(`BalanÃ§o do mÃªs:
    Recebido: R$${myIncome},00
    Gasto: R$${totalExpenses},00
    Saldo: R$${totalAfterExpenses},00 `);
};

const handleExpenses = myExpenses => {
  const eachValue = myExpenses.map((item => Object.values(item)));
  const totalExpense = eachValue.reduce((acc, curr) => acc += curr[0] , 0);
  return totalExpense;
};

monthlyBudget(myIncome, myExpenses, handleExpenses);
// BalanÃ§o do mÃªs:
//     Recebido: R$1000,00
//     Gasto: R$459,00
//     Saldo: R$541,00

// Reparou que vocÃª jÃ¡ estava usando callbacks desde a semana de JavaScript, com eventListeners, e atÃ© a semana passada, com filter, map e reduce ? A funÃ§Ã£o que vocÃª passa como parÃ¢metro para cada uma delas Ã© exemplo de funÃ§Ã£o callback. ğŸ˜‰

// AlÃ©m disso, lembra-se do exemplo da pizza mencionado no Por que isso Ã© importante? O que vocÃª faz quando o pedido da pizza chega, que nesse caso Ã© jantar, corresponde a um callback.

// Antes de seguir para os exercÃ­cios de fixaÃ§Ã£o propostos abaixo, veja o vÃ­deo a seguir para garantir o entendimento sobre callbacks:

// Agora, faÃ§a estes exercÃ­cios de fixaÃ§Ã£o:
// --------------------------------------------------------------------------------

// 1. No cÃ³digo abaixo vocÃª tem a funÃ§Ã£o getUser, que retorna uma pessoa qualquer. Complete a funÃ§Ã£o getUser de forma que ela receba uma outra funÃ§Ã£o como parÃ¢metro para que possa realizar as operaÃ§Ãµes abaixo sobre a pessoa retornada.
const assert = require('assert');
const userFullName = ({ firstName, lastName }) => `Hello! My name is ${firstName} ${lastName}`;
const userNationality = ({ firstName, nationality }) => `${firstName} is ${nationality}`;

const getUser = () => {
  const userToReturn = {
    firstName: "Ivan",
    lastName: "Ivanovich",
    nationality: "Russian"
  };
};

assert.strictEqual(getUser(), "Hello! My name is Ivan Ivanovich"); // complete a chamada da funÃ§Ã£o de getUser
assert.strictEqual(getUser(), "Ivan is Russian"); // complete a chamada da funÃ§Ã£o de getUser


// 2. No cÃ³digo abaixo vocÃª tem a funÃ§Ã£o getUser modificada, que agora funciona de modo assÃ­ncrono e imprime dados de uma pessoa qualquer depois de um certo tempo. Complete a funÃ§Ã£o getUser de forma que ela receba um callback para que possa realizar as operaÃ§Ãµes abaixo sobre a pessoa.
const userFullName = ({ firstName, lastName }) => `Hello! My name is ${firstName} ${lastName}`;
const userNationality = ({ firstName, nationality }) => `${firstName} is ${nationality}`;
const delay = (maxMilliseconds = 5000) => Math.floor(Math.random() * maxMilliseconds);
const getUser = () => {
  setTimeout(() => {
    const user = {
      firstName: "Ivan",
      lastName: "Ivanovich",
      nationality: "Russian",
    };
    console.log(user);
  }, delay());
};

getUser(userFullName); // deve imprimir "Hello! My name is Ivan Ivanovich" depois de um certo tempo
getUser(userNationality); // deve imprimir "Ivan is Russian" depois de um certo tempo

// Obs: note e averigue o comportamento assÃ­ncrono da funÃ§Ã£o getUser ao chamar getUser(userFullName) seguido de getUser(userNationality) . Tem hora que Ã© impresso antes no console o nome da pessoa, e tem hora que Ã© impressa antes a nacionalidade da pessoa!

// --------------------------------------------------------------------------------
Lidando-com-erros-em-operaÃ§Ãµes-assÃ­ncronas

// No Ãºltimo exercÃ­cio, vocÃª deve ter reparado que estÃ¡ usando em conjunto callbacks e assincronicidade, que nesse caso correspondem a:
// - operaÃ§Ã£o assÃ­ncrona: retorno de user depois de um certo tempo, que varia;
// - callbacks : as funÃ§Ãµes userFullName e userNationality , que sÃ£o chamadas depois que o usuÃ¡rio Ã© retornado.

// Nesse caso, a operaÃ§Ã£o assÃ­ncrona sempre finaliza com sucesso, e existe um callback que atua sobre o resultado desse sucesso.

// A funÃ§Ã£o getCountry abaixo tem aproximadamente 50% de chance de obter com sucesso um paÃ­s, tendo um callback para poder ser feita qualquer operaÃ§Ã£o sobre o paÃ­s retornado. Adicione um outro callback para getCountry , de forma que trate a mensagem de erro retornada.
const countryName = ({ name }) => console.log(`Returned country is ${name}`);
const countryCurrency = ({ name, currency }) => console.log(`${name}'s currency is the ${currency}`);
const delay = (maxMilliseconds = 5000) => Math.floor(Math.random() * maxMilliseconds);
const printErrorMessage = (error) => console.log(`Error getting country: ${error}`);
const getCountry = (onSuccess) => {
  setTimeout(() => {
    const didOperationSucceed = Math.random() >= 0.5;
    if(didOperationSucceed) {
      const country = {
        name: "Brazil",
        hdi: 0.759,
        currency: "Real",
      };
      onSuccess(country);
    }
    else {
      const errorMessage = "Country could not be found";
    }
  }, delay());
};

// Deve imprimir "Returned country is Brazil" no sucesso, ou "Error getting country: Country could not be found" em falha
getCountry(countryName, printErrorMessage);

// Deve imprimir "Brazil's currency is the Real" no sucesso, ou "Error getting country: Country could not be found" em falha
getCountry(countryCurrency, printErrorMessage);

// --------------------------------------------------------------------------------
Fetch-API

// No contexto do Front-end, a maioria dos casos em que precisamos utilizar funÃ§Ãµes assÃ­ncronas sÃ£o em requisiÃ§Ãµes. Um bom exemplo Ã© a funÃ§Ã£o fetch() da Fetch API!
// A Fetch API contÃ©m uma sÃ©rie de recursos desenvolvidos para lidar com requisiÃ§Ãµes http no JavaScript. A funÃ§Ã£o primÃ¡ria Ã© a fetch() , utilizada para fazer chamadas Ã s URL's das APIs . Trata-se de uma funÃ§Ã£o assÃ­ncrona, baseada em uma promise.
// Uma API, por sua vez, Ã© uma forma de trafegar dados entre aplicaÃ§Ãµes. Por exemplo: existe uma API que todos os dias possui uma piada diferente. A URL da API Ã© https://api.jokes.one . Portanto, se quisermos ter acesso a essa piada, precisamos fazer uma requisiÃ§Ã£o para a URL da API, solicitando os dados. A API, por sua vez, vai analisar a requisiÃ§Ã£o e responder os dados pedidos. Note que hÃ¡ um tempo entre a requisiÃ§Ã£o ser enviada e a resposta ser devolvida. Por isso, precisamos que a requisiÃ§Ã£o seja assÃ­ncrona.

// A funÃ§Ã£o fetch recebe dois parÃ¢metros:
// - URL do serviÃ§o alvo da requisiÃ§Ã£o;
// - Um objeto contendo algumas informaÃ§Ãµes sobre requisiÃ§Ã£o de API. Esse objeto contÃ©m chaves com informaÃ§Ãµes especÃ­ficas para aquela chamada. Essas especificaÃ§Ãµes estÃ£o sempre presentes na documentaÃ§Ã£o de uso daquela API especÃ­fica. NÃ£o se preocupe muito em como obter essas informaÃ§Ãµes por agora ; nesse inÃ­cio, daremos essas informaÃ§Ãµes para que vocÃªs se acostumem a usar o .fetch() .

// O retorno da chamada varia conforme a API utilizada, nÃ£o sÃ³ em conteÃºdo, mas tambÃ©m formato. Como nosso maior foco Ã© JavaScript, lidaremos principalmente com respostas em formato JSON, ou respostas que possam ser reformatadas para tal.



// coteÃºdo aula ao vivo
// --------------------------------------------------------------------------------

// EX 01 - ------------------------------------
const wait = (miliseconds) => {
  const now = new Date().getTime();
  while (new Date().getTime() < now + miliseconds);
};
function func1() {
  wait(3000);
  console.log('FunÃ§Ã£o 1');
}
function func2() {
  wait(3000);
  console.log('FunÃ§Ã£o 2');
}
console.log('OlÃ¡! O cÃ³digo comeÃ§ou a ser executado.');
func1();
func2();


// EX 02 - ------------------------------------
function func1() {
  setTimeout(() => {
    console.log('FunÃ§Ã£o 1');
  }, 3000);
}
function func2() {
  setTimeout(() => {
    console.log('FunÃ§Ã£o 2');
  });
}
console.log('OlÃ¡! O cÃ³digo comeÃ§ou ser executado.');
func1();
func2();
console.log('Tchau! o cÃ³digo terminou.');


// EX 03 - ------------------------------------
function func1() {
  setTimeout(() => {
    console.log('FunÃ§Ã£o 1');
  }, Math.random() * 3000);
}
function func2() {
  setTimeout(() => {
    console.log('FunÃ§Ã£o 2');
  }, Math.random() * 3000);
}
console.log('OlÃ¡! O cÃ³digo comeÃ§ou ser executado.');
func1();
func2();
console.log('Tchau! o cÃ³digo terminou.');

// EX 04 - ------------------------------------
function func2() {
  setTimeout(() => {
    console.log('FunÃ§Ã£o 2');
  }, Math.random() * 3000);
}
function func1() {
  setTimeout(() => {
    console.log('FunÃ§Ã£o 1');
    func2();
  }, Math.random() * 3000);
}
console.log('OlÃ¡! O cÃ³digo comeÃ§ou ser executado.');
func1();
console.log('Tchau! o cÃ³digo terminou.');

// EX 05 - ------------------------------------
function func2() {
  setTimeout(() => {
    console.log('FunÃ§Ã£o 2');
  }, Math.random() * 3000);
}
function func3() {
  setTimeout(() => {
    console.log('FunÃ§Ã£o 3');
  }, Math.random() * 3000);
}
function func1(callback) {
  setTimeout(() => {
    console.log('FunÃ§Ã£o 1');
    callback('Icaro');
  }, Math.random() * 3000);
}
console.log('OlÃ¡! O cÃ³digo comeÃ§ou ser executado.');
func1(func2);
func3();
console.log('Tchau! o cÃ³digo terminou.');

// EX 06 ------------------------------------
function renderCountry(country) {
  const ul = document.querySelector('ul');
  const li = document.createElement('li');
  li.innerHTML = `${countries.nativeName} - ${countries.capital}`;
  ul.appendChild(li);
  console.log(countries);
}

function fetchCountry(name) {
  return fetch(`https://restcountries.eu/rest/v2/name/${name}`)
  .then((response) => {
    response.json()
    .then((countries) => {
      renderCountry(countries[0]);
      fetch('https://restcountries.eu/rest/v2/name/brazil')
      .then(response) => {
          response.json()
          .then((countries) => {
            renderCountry(countries[0]);
          })
      }
    });
  });
}
window.onload = () => {
  fetchCountry('brasil');
  fetchCountry('china');
  fetchCountry('usa');
};

// ExercÃ­cios para finalizar o dia ------------------------------------
// Hora de por a mÃ£o na massa!
