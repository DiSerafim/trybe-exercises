============================== Updates Complexos - Arrays - Parte 2
-- > CONTEÚDO do dia - 25.1 -- <---/ INICIO --------------------------------------//
==============================

# Executar operações de soma e subtração de valores em um pipeline;
# Trabalhar com datas em pipelines, adicionando ou subtraindo tempo;
# Executar operações de multiplicação e divisão em pipelines, utilizando valores fixos ou variáveis;
# Adicionar novos campos aos documentos durante um pipeline.

### Aplicando condições ao (Join com $lookup)
# pode referenciar campos dos documentos de entrada para serem utilizados nas condições e montar um pipeline dentro dele.

# let: define as variáveis que serão utilizadas no estágio pipeline dentro do '$lookup'. O estágio pipeline não consegue acessar diretamente os campos dos documentos de entrada, os campos precisam ser definidos previamente e transformados em variáveis;
# pipeline: define as condições ou o pipeline que será executado na coleção de junção. Se quiser todos os documentos da coleção de junção, é só especificá-lo como vazio ([]).

# $match em conjunto com os demais operadores $eq e $gte.
# $eq é responsável por verificar quais itens tem os mesmos valores para o que declaramos em $$ordem_item e $stock_item que é o nome da nossa chave.
# $gte para os documentos que foram alinhados.

> use example_db;
> db.orders.insertMany([
  { _id: 1, item: "almonds", price: 12, ordered: 2 },
  { _id: 2, item: "pecans", price: 20, ordered: 1 },
  { _id: 3, item: "cookies", price: 10, ordered: 60 }
]);
{ "acknowledged" : true, "insertedIds" : [ 1, 2, 3 ] }
> use example_db;
> db.warehouses.insertMany([
  { _id: 1, stock_item: "almonds", warehouse: "A", instock: 120 },
  { _id: 2, stock_item: "pecans", warehouse: "A", instock: 80 },
  { _id: 3, stock_item: "almonds", warehouse: "B", instock: 60 },
  { _id: 4, stock_item: "cookies", warehouse: "B", instock: 40 },
  { _id: 5, stock_item: "cookies", warehouse: "A", instock: 80 }
]);
{ "acknowledged" : true, "insertedIds" : [ 1, 2, 3, 4, 5 ] }

# junta todos os documentos da coleção 'orders' com a coleção 'warehouse' através do campo item se a quantidade em estoque (instock) for suficiente para cobrir a quantidade vendida (ordered). Os documentos que dão match são colocados no campo stockdata.
> db.orders.aggregate([
  {
    $lookup: {
      from: "warehouses",
      let: { order_item: "$item", order_qty: "$ordered" },
      pipeline: [
        {
          $match: {
            $expr: {
              $and: [
                { $eq: [ "$stock_item",  "$$order_item" ] },
                { $gte: [ "$instock", "$$order_qty" ] }
              ]
            }
          }
        },
        { $project: { stock_item: 0, _id: 0 } }
      ],
      as: "stockdata"
    }
  }
]).pretty();
# resultado
# dentro do estágio pipeline, temos um operador $match que utiliza uma expressão ($expr). Esta, por sua vez, utiliza o operador $and. Dentro do $and, são utilizados operadores de igualdade ($eq) e de comparação ( $gte ). O símbolo $ é utilizado para se referir aos campos da coleção warehouse (a coleção de junção), enquanto $$ se refere às variáveis definidas no estágio let (os campos da coleção orders).
# resultado
{
  "_id" : 1,
  "item" : "almonds",
  "price" : 12,
  "ordered" : 2,
  "stockdata" : [
    { "warehouse": "A", "instock": 120},
    { "warehouse": "B", "instock": 60 }
  ]
}
{
  "_id" : 2,
  "item" : "pecans",
  "price" : 20,
  "ordered" : 1,
  "stockdata" : [{ "warehouse": "A", "instock": 80}]
}
{
  "_id" : 3,
  "item" : "cookies",
  "price" : 10,
  "ordered" : 60,
  "stockdata" : [{ "warehouse": "A", "instock": 80 }]
}

# Para Fixar

> use agg_example;
> db.clients.insertMany([
  { name: "Dave America", State: "Florida" },
  { name: "Ned Flanders", State: "Alasca" },
  { name: "Mark Zuck", State: "Texas" },
  { name: "Edna Krabappel", State: "Montana" },
  { name: "Arnold Schuz", State: "California" },
  { name: "Lisa Simpson", State: "Florida" },
  { name: "Barney Gumble", State: "Texas" },
  { name: "Homer Simpson", State: "Florida" },
]);
"acknowledged" : true,

# 1 Selecione todos os clientes com as suas respectivas transações feitas;
> db.clients.aggregate([
  {
    $lookup: {
      from: "transactions",
      let: { user_name: "$name" },
      pipeline: [{
        $match: {
          $expr: {
            $eq: ["$from", "$$user_name"],
          }
        }
      }],
      as: "transacoes"
    }
  }
]).pretty();
# retorno +
{
  "_id" : ObjectId("611d8643be7d4f068352e802"),
  "name" : "Dave America",
  "State" : "Florida",
  "transacoes" : [
    {
      "_id" : ObjectId("611d2c892742406fe2ccb7b9"),
      "value" : 5900,
      "from" : "Dave America",
      "to" : "Ned Flanders",
      "bank" : "International"
    },
    {
      "_id" : ObjectId("611d2c892742406fe2ccb7bf"),
      "value" : 1280,
      "from" : "Dave America",
      "to" : "Home Simpson",
      "bank" : "Citigroup"
    }
  ]
}

# 2 Selecione os quatro primeiros clientes com as suas respectivas transações recebidas ordenados pelo estado em ordem alfabética;
> db.clients.aggregate([
  {
    $lookup: {
      from: "transactions",
      let: { user_name: "$name" },
      pipeline: [{
        $match: {
          $expr: {
            $eq: ["$to", "$$user_name"],
          }
        }
      }],
      as: "received_transactions"
    },
  },
  { $sort: { State: 1 } },
  { $limit: 4 }
]).pretty();
# retorno +4
{
  "_id" : ObjectId("611d8643be7d4f068352e803"),
  "name" : "Ned Flanders",
  "State" : "Alasca",
  "received_transactions" : [
    {
      "_id" : ObjectId("611d2c892742406fe2ccb7b9"),
      "value" : 5900,
      "from" : "Dave America",
      "to" : "Ned Flanders",
      "bank" : "International"
    },
    {
      "_id" : ObjectId("611d2c892742406fe2ccb7c0"),
      "value" : 7000,
      "from" : "Arnold Schuz",
      "to" : "Ned Flanders",
      "bank" : "International"
    }
  ]
}

# 3 Selecione todos os cliente do estado da "Florida" e suas respectivas transações recebidas.
> db.clients.aggregate([
  { $match: { State: "Florida" } },
  {
    $lookup: {
      from: "transactions",
      let: { user_name: "$name" },
      pipeline: [{
        $match: {
          $expr: {
            $eq: ["$to", "$$user_name"],
          }
        }
      }],
      as: "received_transactions"
    },
  },
]).pretty();
# retorno +
{
  "_id" : ObjectId("611d8643be7d4f068352e802"),
  "name" : "Dave America",
  "State" : "Florida",
  "received_transactions" : [
    {
      "_id" : ObjectId("611d2c892742406fe2ccb7bb"),
      "value" : 290,
      "from" : "Lisa Simpson",
      "to" : "Dave America",
      "bank" : "bankOfAmerica"
    }
  ]
}

### Expressão $add
# soma valores numéricos ou datas. Se um dos argumentos for do tipo date, o outro argumento será tratado como milissegundos e adicionado à data.

> use storage;
> db.products.insertMany([
  { "name": "Ball", "purchase_price": 7.6, "taxes": 1.9, "sale_price": 12.5, "quantity": 5 },
  { "name": "Baseball bat", "purchase_price": 18.5, "taxes": 5.3, "sale_price": 39.9, "quantity": 12 },
  { "name": "Sneakers", "purchase_price": 10.4, "taxes": 1.50, "sale_price": 14.9, "quantity": 3 },
  { "name": "Gloves", "purchase_price": 2.85, "taxes": 0.90, "sale_price": 5.70, "quantity": 34 },
  { "name": "Jacket", "purchase_price": 28.9, "taxes": 10.80, "sale_price": 59.9, "quantity": 20 },
  { "name": "Mousepad", "purchase_price": 16.6, "taxes": 3.40, "sale_price": 29.9, "quantity": 8 },
  { "name": "Monitor", "purchase_price": 119.9, "taxes": 39.20, "sale_price": 240.6, "quantity": 11 },
]);
"acknowledged" : true,

# coleção sales
> db.sales.insertMany([
  { _id: 1, item: "abc", price: 10, fee: 2, date: ISODate("2014-03-01T08:00:00Z") },
  { _id: 2, item: "jkl", price: 20, fee: 1, date: ISODate("2014-03-01T09:00:00Z") },
  { _id: 3, item: "xyz", price: 5,  fee: 0, date: ISODate("2014-03-15T09:00:00Z") }
]);
{ "acknowledged" : true, "insertedIds" : [ 1, 2, 3 ] }

# Utilizando a expressão $add no estágio $project , você pode criar um novo campo com o valor total somando os campos price e fee.
> db.sales.aggregate([
  {
    $project: {
      item: 1,
      total: {
        $add: ["$price", "$fee"]
      }
    }
  }
]);
# retorno
{ "_id": 1, "item": "abc", "total": 12 }
{ "_id": 2, "item": "jkl", "total": 21 }
{ "_id": 3, "item": "xyz", "total": 5 }

# Para valores do tipo date, um dos argumentos sempre será tratado como milissegundos.

# adicionar 3 dias ao valor do campo date. 

# 1°opção passar em um dos argumentos o número equivalente a 3 dias em milissegundos (2,592e+8).
> db.sales.aggregate([
  {
    $project: {
      item: 1,
      billing_date: {
        $add: ["$date", 2.592e+8]
      }
    }
  }
]).pretty();
# retorno
{
  "_id" : 1,
  "item" : "abc",
  "billing_date" : ISODate("2014-03-04T08:00:00Z")
}
{
  "_id" : 2,
  "item" : "jkl",
  "billing_date" : ISODate("2014-03-04T09:00:00Z")
}
{
  "_id" : 3,
  "item" : "xyz",
  "billing_date" : ISODate("2014-03-18T09:00:00Z")
}

# 2°opção criar uma expressão que devolva esse número:
> db.sales.aggregate([
  {
    $project: {
      item: 1,
      billing_date: {
        $add: ["$date", 3 * 24 * 60 * 60000]
      }
    }
  }
]).pretty();
# resultado
{
  "_id" : 1,
  "item" : "abc",
  "billing_date" : ISODate("2014-03-04T08:00:00Z")
}
{
  "_id" : 2,
  "item" : "jkl",
  "billing_date" : ISODate("2014-03-04T09:00:00Z")
}
{
  "_id" : 3,
  "item" : "xyz",
  "billing_date" : ISODate("2014-03-18T09:00:00Z")
}

# Para Fixar

> use storage;
# Calcule qual o custo total de cada produto, considerando o preço de compra e os impostos.
> db.products.aggregate([
  {
    $project: {
      _id: 0,
      name: 1,
      totalCadaProduto: {
        $add: ["$taxes", "$purchase_price"]
      }
    }
  },
]).pretty();
# resultado
{ "name": "Ball", "totalCadaProduto": 9.5 }
{ "name": "Baseball bat", "totalCadaProduto": 23.8 }
{ "name": "Sneakers", "totalCadaProduto": 11.9 }
{ "name": "Gloves", "totalCadaProduto": 3.75 }
{ "name": "Jacket", "totalCadaProduto": 39.7 }
{ "name": "Mousepad", "totalCadaProduto": 20 }
{ "name": "Monitor", "totalCadaProduto": 159.10000000000002 }

### Expressão $subtract
# subtrai 2 valores numéricos para retornar a diferença entre eles, ou 2 datas para retornar a diferença entre elas em milissegundos.
# O 2° argumento sempre será subtraído do 1°

> use sales;
> db.supplies.insertMany([
  {
    _id: 4,
    item: "abc",
    price: 10,
    fee: 2,
    discount: 5,
    date: ISODate("2014-03-01T08:00:00Z")
  },
  {
    _id: 5,
    item: "jkl",
    price: 20,
    fee: 1,
    discount: 2,
    date: ISODate("2014-03-01T09:00:00Z")
  }
]);
{ "acknowledged" : true, "insertedIds" : [ 4, 5 ] }

# utilizando $add para calcular o total e o $subtract para aplicar um desconto no subtotal.
> db.supplies.aggregate([
  {
    $project: {
      item: 1,
      total: {
        $subtract: [
          { $add: ["$price", "$fee"] },
          "$discount"
        ]
      }
    }
  }
]).pretty();
# Observe que um dos argumentos do $subtract é o resultado de uma expressão ($add) que soma dois campos da coleção (price e fee). O segundo argumento (valor a ser subtraído) recebe o campo $discount.
# resultado
{ "_id" : 1, "total" : null }
{ "_id" : 2, "total" : null }
{ "_id" : 3, "total" : null }
{ "_id" : 4, "item" : "abc", "total" : 7 }
{ "_id" : 5, "item" : "jkl", "total" : 19 }

# ubtrai o valor do campo date da data corrente, utilizando a variável de sistema NOW e retorna a diferença em milissegundos:
> db.sales.aggregate([
  {
    $project: {
      item: 1,
      dateDifference: {
        $subtract: ["$$NOW", "$date"]
      }
    }
  }
]).pretty();
# resultado
{
  "_id": 1,
  "item": "abc",
  "dateDifference": NumberLong("235747629729")
}
{
  "_id": 2,
  "item": "jkl",
  "dateDifference": NumberLong("235744029729")
}
{
  "_id": 3,
  "item": "xyz",
  "dateDifference": NumberLong("234534429729")
}

# Alternativamente, você pode utilizar a função Date() para obter a data corrente:
> db.sales.aggregate([
  {
    $project: {
      item: 1,
      dateDifference: {
        $subtract: [new Date(), "$date"]
      }
    }
  }
]).pretty();
# resultado
{
  "_id": 1,
  "item" : "abc",
  "dateDifference" : NumberLong("235747961224")
}
{
  "_id": 2,
  "item" : "jkl",
  "dateDifference" : NumberLong("235744361224")
}
{
  "_id": 3,
  "item" : "xyz",
  "dateDifference" : NumberLong("234534761224")
}

# também pode utilizar milissegundos como argumento da subtração. 
# subtrai 5 minutos do campo date :
> db.sales.aggregate([
  {
    $project: {
      item: 1,
      dateDifference: {
        $subtract: ["$date", 5 * 60 * 1000]
      }
    }
  }
]);
# resultado
{
  "_id": 1,
  "item": "abc",
  "dateDifference" : ISODate("2014-03-01T07:55:00Z")
}
{
  "_id": 2,
  "item": "jkl",
  "dateDifference" : ISODate("2014-03-01T08:55:00Z")
}
{
  "_id": 3,
  "item": "xyz",
  "dateDifference" : ISODate("2014-03-15T08:55:00Z")
}

# Para Fixar

> use storage;
# Calcule qual o lucro total de cada produto, considerando o preço de compra, os impostos e seu valor de venda.
> db.products.aggregate([
  {
    $project: {
      _id: 0,
      name: 1,
      total_profit: {
        $subtract: [
          "$sale_price",
          { $add: ["$taxes", "$purchase_price"] }
        ]
      }
    }
  },
]).pretty();
# resultado
{ "name": "Ball", "total_profit": 3 }
{ "name": "Baseball bat", "total_profit": 16.099999999999998 }
{ "name": "Sneakers", "total_profit": 3 }
{ "name": "Gloves", "total_profit": 1.9500000000000002 }
{ "name": "Jacket", "total_profit": 20.199999999999996 }
{ "name": "Mousepad", "total_profit": 9.899999999999999 }
{ "name": "Monitor", "total_profit": 81.49999999999997 }

### Expressão $ceil
# arredonda o número especificado para "cima". executa a função matemática teto que converte um número x no número inteiro mais próximo, que seja maior ou igual a x.

> use samples;
> db.samples.insertMany([
  { _id: 1, value: 9.25 },
  { _id: 2, value: 8.73 },
  { _id: 3, value: 4.32 },
  { _id: 4, value: -5.34 }
]);
{ "acknowledged" : true, "insertedIds" : [ 1, 2, 3, 4 ] }

# utilize a expressão $ceil no estágio $project para retornar um novo campo chamado ceilingValue
> db.samples.aggregate([
  {
    $project: {
      value: 1,
      ceilingValue: { $ceil: "$value" }
    }
  }
]);
# O valor original também é retornado:
# resultado
{ "_id": 1, "value": 9.25, "ceilingValue": 10 }
{ "_id": 2, "value": 8.73, "ceilingValue": 9 }
{ "_id": 3, "value": 4.32, "ceilingValue": 5 }
{ "_id": 4, "value": -5.34, "ceilingValue": -5 }

### Expressão $floor
# retorna o maior número inteiro menor ou igual ao número especificado, faz um arredondamento para baixo.

# Se aplicar a expressão $floor no estágio $project :
> db.samples.aggregate([
  {
    $project: {
      value: 1,
      floorValue: { $floor: "$value" }
    }
  }
]);
# Terá o retorno do valor original e o calculado:
# resultado
{ "_id": 1, "value": 9.25, "floorValue": 9 }
{ "_id": 2, "value": 8.73, "floorValue": 8 }
{ "_id": 3, "value": 4.32, "floorValue": 4 }
{ "_id": 4, "value": -5.34, "floorValue": -6 }

### Expressão $round
# Retorna o número inteiro mais próximo do valor atual e também permite definir a quantidade de casas decimais que se quer manter ao arredondar.

# Se aplicar a expressão $round no estágio $project.
> db.samples.aggregate([
  {
    $project: {
      value: 1,
      roundedValue: { $round: ["$value"] }
    }
  }
]);
# Terá o retorno do valor original e o calculado:
# resultado
{ "_id": 1, "value": 9.25, "roundedValue": 9 }
{ "_id": 2, "value": 8.73, "roundedValue": 9 }
{ "_id": 3, "value": 4.32, "roundedValue": 4 }
{ "_id": 4, "value": -5.34, "roundedValue": -5 }

# Observe que para todos os valores, o $round arredondou os valores para o mais próximo, podendo ser maior ou menor.
# Essa é uma das diferenças do $round para o $ceil e para o $floor.
# caso, passemos um segundo parâmetro ele vai arredondar mantendo a quantidade de casas decimais que for definida.
> db.samples.aggregate([
  {
    $project: {
      value: 1,
      roundedValue: { $round: ["$value", 1] }
    }
  }
]);
# Terá o retorno do valor original e o calculado:
# resultado
{ "_id": 1, "value": 9.25, "roundedValue": 9.2 }
{ "_id": 2, "value": 8.73, "roundedValue": 8.7 }
{ "_id": 3, "value": 4.32, "roundedValue": 4.3 }
{ "_id": 4, "value": -5.34, "roundedValue": -5.3 }

# Para Fixar
> use storage;

# 1 Retorne o menor número inteiro relativo ao preço de venda de cada produto;
> db.products.aggregate([
  {
    $project: {
      _id: 0,
      name: 1,
      menor_preco: { $floor: "$sale_price" }
    }
  },
]).pretty();
# resultdado
{ "name": "Ball", "menor_preco": 12 }
{ "name": "Baseball bat", "menor_preco": 39 }
{ "name": "Sneakers", "menor_preco": 14 }
{ "name": "Gloves", "menor_preco": 5 }
{ "name": "Jacket", "menor_preco": 59 }
{ "name": "Mousepad", "menor_preco": 29 }
{ "name": "Monitor", "menor_preco": 240 }

# 2 Retorne o maior número inteiro relativo ao lucro total sobre cada produto.
> db.products.aggregate([
  {
    $project: {
      _id: 0,
      name: 1,
      maior_preco: {
        $ceil: {
          $subtract: ["$sale_price", "$purchase_price"]
        }
      }
    }
  }
]).pretty();
# resultado
{ "name": "Ball", "maior_preco": 5 }
{ "name": "Baseball bat", "maior_preco": 22 }
{ "name": "Sneakers", "maior_preco": 5 }
{ "name": "Gloves", "maior_preco": 3 }
{ "name": "Jacket", "maior_preco": 31 }
{ "name": "Mousepad", "maior_preco": 14 }
{ "name": "Monitor", "maior_preco": 121 }

### Expressão $abs
# retorna o valor absoluto de um número.
# muito útil para encontrar a diferença entre dois valores.

> use ratings;
> db.ratings.insertMany([
  { _id: 1, start: 5, end: 8 },
  { _id: 2, start: 4, end: 4 },
  { _id: 3, start: 9, end: 7 },
  { _id: 4, start: 6, end: 7 }
]);
{ "acknowledged" : true, "insertedIds" : [ 1, 2, 3, 4 ] }

# $abs combinada com a expressão $subtract no estágio $project, podemos retornar a diferença entre os valores dos campos start e end.
> db.ratings.aggregate([
  {
    $project: {
      delta: {
        $abs: {
          $subtract: ["$start", "$end"]
        }
      }
    }
  }
]);
# resultado
{ "_id": 1, "delta": 3 }
{ "_id": 2, "delta": 0 }
{ "_id": 3, "delta": 2 }
{ "_id": 4, "delta": 1 }

#Para Fixar

> use storage;
# Calcule o valor absoluto do lucro total de cada produto.
> db.products.aggregate([
  {
    $project: {
      _id: 0,
      name: 1,
      delta: {
        $abs: {
          $subtract: [
            "$sale_price",
            { $add: ["$taxes", "$purchase_price"] }
          ]
        }
      }
    }
  }
]).pretty();
# resultado
{ "name": "Ball", "delta": 3 }
{ "name": "Baseball bat", "delta": 16.099999999999998 }
{ "name": "Sneakers", "delta": 3 }
{ "name": "Gloves", "delta": 1.9500000000000002 }
{ "name": "Jacket", "delta": 20.199999999999996 }
{ "name": "Mousepad", "delta": 9.899999999999999 }
{ "name": "Monitor", "delta": 81.49999999999997 }

### Expressão $multiply
# multiplica dois valores numéricos. Esses valores devem ser passados num array.

> db.sales.insertMany([
  { _id: 4, item: "abc", price: 10, quantity: 2, date: ISODate("2014-03-01T08:00:00Z") },
  { _id: 5, item: "jkl", price: 20, quantity: 1, date: ISODate("2014-03-01T09:00:00Z") },
  { _id: 6, item: "xyz", price: 5, quantity: 10, date: ISODate("2014-03-15T09:00:00Z") }
]);
{ "acknowledged" : true, "insertedIds" : [ 4, 5, 6 ] }

# $multiply no estágio $project para projetar um novo campo chamado total, que conterá o valor da multiplicação entre os campos price e quantity.
> db.sales.aggregate([
  {
    $project: {
      date: 1,
      item: 1,
      total: {
        $multiply: ["$price", "$quantity"]
      }
    }
  }
]);
# resultado
{
  "_id": 4,
  "item": "abc",
  "date": ISODate("2014-03-01T08:00:00Z"),
  "total": 20 
}
{
  "_id": 5,
  "item": "jkl",
  "date": ISODate("2014-03-01T09:00:00Z"),
  "total": 20 
}
{
  "_id": 6,
  "item": "xyz",
  "date": ISODate("2014-03-15T09:00:00Z"),
  "total": 50 
}

# Para Fixar

> use storage;
# 1 Calcule qual o valor total em estoque de cada produto, considerando o preço de venda e a quantidade;
> db.products.aggregate([
  {
    $project: {
      _id: 0,
      name: 1,
      estoque_cada_produto: {
        $multiply: ["$sale_price", "$quantity"]
      }
    }
  },
]).pretty();
# resultado
{ "name": "Ball", "estoque_cada_produto": 62.5 }
{ "name": "Baseball bat", "estoque_cada_produto": 478.79999999999995 }
{ "name": "Sneakers", "estoque_cada_produto": 44.7 }
{ "name": "Gloves", "estoque_cada_produto": 193.8 }
{ "name": "Jacket", "estoque_cada_produto": 1198 }
{ "name": "Mousepad", "estoque_cada_produto": 239.2 }
{ "name": "Monitor", "estoque_cada_produto": 2646.6 }

# 2 Calcule qual será o lucro total de cada produto caso todo o estoque seja vendido.
> db.products.aggregate([
  {
    $project: {
      _id: 0,
      name: 1,
      lucro_total_produto: {
        $multiply: [
          {
            $subtract: [
              "$sale_price",
              { $add: ["$taxes", "$purchase_price"] }
            ]
          },
          "$quantity"
        ]
      }
    }
  }
]).pretty();
# resultado
{
  "name": "Ball",
  "lucro_total_produto": 15
}
{
  "name": "Baseball bat",
  "lucro_total_produto": 193.2
}
{
  "name": "Sneakers",
  "lucro_total_produto": 9
}
{
  "name": "Gloves",
  "lucro_total_produto": 66.30000000000001
}
{
  "name": "Jacket",
  "lucro_total_produto": 403.9999999999999
}
{
  "name": "Mousepad",
  "lucro_total_produto": 79.19999999999999
}
{
  "name": "Monitor",
  "lucro_total_produto": 896.4999999999997
}

### Expressão $divide
# divide 2 valores. O 1° argumento é o dividendo, e o 2° é o divisor.

> use planning;
> db.planning.insertMany([
  { _id: 1, name: "A", hours: 80, resources: 7 },
  { _id: 2, name: "B", hours: 40, resources: 4 }
]);
{ "acknowledged" : true, "insertedIds" : [ 1, 2 ] }

# o $divide para dividir o valor do campo hours por 8 e calcular o número de dias de trabalho (workdays):
> db.planning.aggregate([
  {
    $project: {
      name: 1,
      workdays: {
        $divide: ["$hours", 8]
      }
    }
  }
]);
# resultado
{ "_id": 1, "name": "A", "workdays": 10 }
{ "_id": 2, "name": "B", "workdays": 5 }

# Para Fixar
> use storage;
# Calcule qual será o preço de venda de cada produto caso haja uma promoção de 50% de desconto.
> db.products.aggregate([
  {
    $project: {
      _id: 0,
      name: 1,
      preco_venda_promocao: {
        $subtract: [
          "$sale_price",
          {
            $multiply: [
              { $divide: [50, 100] },
              "$sale_price"
            ]
          }
        ]
      }
    }
  }
]).pretty();
# resultado
{ "name": "Ball", "preco_venda_promocao": 6.25 }
{ "name": "Baseball bat", "preco_venda_promocao": 19.95 }
{ "name": "Sneakers", "preco_venda_promocao": 7.45 }
{ "name": "Gloves", "preco_venda_promocao": 2.85 }
{ "name": "Jacket", "preco_venda_promocao": 29.95 }
{ "name": "Mousepad", "preco_venda_promocao": 14.95 }
{ "name": "Monitor", "preco_venda_promocao": 120.3 }

### Estágio $addFields
# estágio que adiciona novos campos aos documentos. A saída desse estágio conterá todos os campos existentes nos documentos de entrada e adicionará os novos campos especificados.
# pode incluir subdocumentos ou arrays de subdocumentos, utilizando o conceito de dot notation. Um pipeline pode conter mais de um estágio $addFields

> use agg_example;
# atual
{
  "_id" : ObjectId("611d2c892742406fe2ccb7b9"),
  "value" : 5900,
  "from" : "Dave America",
  "to" : "Ned Flanders",
  "bank" : "International",
}

> db.transactions.aggregate([
  {
    $addFields: {
      novoValor: {
        $sum: ["$value", 1000]
      }
    }
  }
]).pretty();
# resultado
{
  "_id" : ObjectId("611d2c892742406fe2ccb7b9"),
  "value" : 5900,
  "from" : "Dave America",
  "to" : "Ned Flanders",
  "bank" : "International",
  "novoValor" : 6900
}

> use scores;
> db.scores.insertMany([
  {
    _id: 1,
    student: "Maya",
    homework: [10, 5, 10],
    quiz: [10, 8],
    extraCredit: 0
  },
  {
    _id: 2,
    student: "Ryan",
    homework: [5, 6, 5],
    quiz: [8, 8],
    extraCredit: 8
  }
]);
{ "acknowledged" : true, "insertedIds" : [ 1, 2 ] }

# $addFields duas vezes para incluir três novos campos nos documentos de saída:
> db.scores.aggregate([
  {
    $addFields: {
      totalHomework: { $sum: "$homework" },
      totalQuiz: { $sum: "$quiz" }
    }
  },
  {
    $addFields: {
      totalScore: {
        $add: [ "$totalHomework", "$totalQuiz", "$extraCredit" ]
      }
    }
  }
]);
# O !° estágio adiciona o campo 'totalHomework' somando os valores contidos no array 'homework'. Também adiciona outro campo chamado 'totalQuiz' somando os valores do array 'quiz'.
# O 2° estágio adiciona o campo 'totalScore', que soma os valores dos campos 'totalHomework', 'totalQuiz' e 'extraCredit'.
# resultado
{
  "_id": 1,
  "student": "Maya",
  "homework": [ 10, 5, 10 ],
  "quiz": [ 10, 8 ],
  "extraCredit": 0,
  "totalHomework": 25,
  "totalQuiz": 18,
  "totalScore": 43
}
{
  "_id": 2,
  "student": "Ryan",
  "homework": [ 5, 6, 5 ],
  "quiz": [ 8, 8 ],
  "extraCredit": 8,
  "totalHomework": 16,
  "totalQuiz": 16,
  "totalScore": 40
}

# Para Fixar

> use storage;
# Calcule o valor total do estoque, considerando que cada produto valha o mesmo que seu preço de venda. Lembre-se da quantidade.
> db.products.aggregate([
  {
    $addFields: {
      valor_total_stoque: {
        $multiply: ["$sale_price", "$quantity"]
      }
    }
  }
]).pretty();
# resultado +
{
  "_id" : ObjectId("611ebe70ebfc61a366ad3edb"),
  "name" : "Ball",
  "purchase_price" : 7.6,
  "taxes" : 1.9,
  "sale_price" : 12.5,
  "quantity" : 5,
  "valor_total_stoque" : 62.5
}


### Cheat Sheet
?

# O operador $group contém o campo _id que, quando seleciona um campo precedido por $, retorna os valores distintos do mesmo.

### Fixando
# 1.
Marque a alternativa que completa corretamente o texto a seguir: O _________ é um estágio que adiciona novos campos aos documentos. A _________ desse estágio conterá todos os campos existentes nos documentos de entrada e _________ os novos campos especificados. Um pipeline pode conter _________ um estágio desse tipo.
# $addFields, saída, adicionará, mais de.
Essa alternativa está correta. O $addFields é um estágio que adiciona novos campos aos documentos. A saída desse estágio conterá todos os campos existentes nos documentos de entrada e adicionará os novos campos especificados. Um pipeline pode conter mais de um estágio desse tipo.

# 2.
Leia as definições abaixo de expressões utilizadas junto com o operador $lookup e marque a alternativa que apresenta a que elas se referem respectivamente. - Define as variáveis que serão utilizadas no estágio pipeline dentro do $lookup. É necessário porque o estágio pipeline não consegue acessar diretamente os campos dos documentos de entrada, então esses campos precisam ser definidos previamente e transformados em variáveis. - Define as condições ou o pipeline que será executado na coleção de junção. Se você quiser todos os documentos da coleção de junção, é só especificá-lo como vazio ([]).
# $let e pipeline.
Essa alternativa está correta. A expressão $let define as variáveis que serão utilizadas no estágio pipeline dentro do $lookup. Isso é necessário porque o estágio pipeline não consegue acessar diretamente os campos dos documentos de entrada, então esses campos precisam ser definidos previamente e transformados em variáveis. Já o estágio pipeline dentro do $lookup define as condições ou estágios que serão executados na coleção de junção. Se você quiser todos os documentos da coleção de junção, é só especificá-lo como vazio ( [] ).

# 3.
Qual dos blocos de código abaixo possui um resultado agregado referente à soma de dois campos?
> db.sales.aggregate([
  { $project: { item: 1, total: { $add: ["$price", "$fee"] } } }
]);
# Essa alternativa está correta porque utiliza no aggregate a expressão $add, que possibilita somar valores numéricos ou datas, no estágio $project, retornando assim a soma dos campos "price" e "fee".

# 4.
Qual expressão completa corretamente a lacuna do bloco de código a seguir, de modo que o retorno seja a diferença entre os dois campos especificados?
Copiar
> db.sales.aggregate([
  {
    $project: { 
      item: 1, total: {
        $_________: ["$price", "$discount"]
      }
    }
  }
]);
# substract
# Essa alternativa está correta, pois a expressão $subtract possibilita subtrair dois valores numéricos para retornar a diferença entre eles, ou duas datas para retornar a diferença entre elas em milissegundos.

# 5.
No contexto das operações de agregação com o aggregate, qual das alternativas a seguir apresenta a função da expressão $ceil?
# Retornar o maior número inteiro mais próximo ao especificado, ou seja, arredondar um valor "para cima".
Essa alternativa está correta. A expressão $ceil basicamente arredonda o número especificado para "cima". Ela executa a função matemática teto que converte um número x no número inteiro mais próximo, que seja maior ou igual a x .

# 6.
Marque a alternativa cujo retorno seja o maior número inteiro menor ou igual ao valor especificado.
> db.samples.aggregate([
  { $project: { item: 1, value: { $floor: "$value" } } }
]);
# Essa alternativa está correta porque utiliza no aggregate a expressão $floor, que retorna um arredondamento para baixo, ou seja, o maior número inteiro menor ou igual ao valor especificado.

# 7.
Sobre a expressão $round, analise os itens a seguir e marque a alternativa que apresenta apenas os itens corretos. I. Ela promove um arredondamento, retornando o número inteiro mais próximo do valor atual. II. Ela permite especificar se o retorno será um arredondamento "para baixo" ou "para cima". III. Ela permite definir a quantidade de casas decimais que você quer manter ao arredondar. IV. Ela precisa de um array como argumento. V. Ela precisa ser utilizada no estágio $project da pipeline.
# I, III e IV.
Essa alternativa está correta. A expressão $round retorna o número inteiro mais próximo do valor atual e também permite definir a quantidade de casas decimais que você quer manter ao arredondar. Além disso, ela precisa de um array como argumento em vez de um valor plano, pois caso haja um segundo parâmetro ele vai arredondar mantendo a quantidade de casas decimais que for definida.

# 8.
Qual expressão completa a lacuna da pipeline a seguir de forma a retornar a magnitude da diferença entre os valores dos campos start e end?
> db.ratings.aggregate([
  {
    $project: {
      delta: {
        ________: { $subtract: ["$start", "$end"] }
      }
    }
  }
]);
# $abs
# Essa alternativa está correta. A expressão $abs retorna o valor absoluto de um número. Combinando essa expressão com a $subtract no estágio $project, podemos retornar a magnitude da diferença entre os valores dos campos "start" e "end", ou seja, considerando apenas sua distância até 0 na reta numérica, onde tanto 1 quanto -1 têm valor absoluto igual a 1, por exemplo.

# 9.
A seguir estão os documentos da collection lanches:
{ "_id" : 1, "item" : "coxinha", "price" : 3, "quantity": 5, }
{ "_id" : 2, "item" : "sanduiche", "price" : 12, "quantity": 3, }
{ "_id" : 3, "item" : "pizza", "price" : 20, "quantity": 1, }
Marque a alternativa que apresenta a operação de agregação realizada a partir dessa collection para que o retorno seja:
{ "_id" : 1, "item" : "coxinha", "total" : 15 }
{ "_id" : 2, "item" : "sanduiche", "total" : 36 }
{ "_id" : 3, "item" : "pizza", "total" : 20 }
> db.lanches.aggregate(
   [
     { $project: { item: 1, total: { $multiply: [ "$price", "$quantity" ] } } }
   ]
)
# Essa alternativa está correta, pois o campo "total", resultante da operação de agregação, corresponde à multiplicação dos campos "$price" e "$quantity" e a alternativa traz o uso da expressão $multiply, utilizada justamente para multiplicar dois valores.

# 10.
Sobre a expressão $divide, julgue os itens a seguir e marque a alternativa que apresenta somente os itens corretos. I. Como o próprio nome sugere, essa expressão é utilizada para dividir dois valores. II. Os argumentos devem ser passados dentro de chaves. III. O primeiro argumento necessário é o dividendo , e o segundo é o divisor. IV. Pode ser utilizado um terceiro argumento para definir as quantidade de casas decimais no arredondamento do resultado.
# I e III.
# Essa alternativa está correta. Como o próprio nome sugere, a expressão $divide é utilizada para dividir dois valores. O primeiro argumento necessário é o dividendo, e o segundo é o divisor. Os argumentos devem ser passados dentro de colchetes. Não há um terceiro argumento, para definir a quantidade de casas decimais no arredondamento do resultado deve-se utilizar em conjunto com $divide a expressão $round.

-- > CONTEÚDO do dia - 25.1 -- <---/ FIM -----------------------------------------//
==============================
-- > AULA ao VIVO - 25.1 ----- <---/ INICIO --------------------------------------//
==============================



-- > AULA ao VIVO - 25.1 ----- <---/ FIM -----------------------------------------//
==============================
-- > EXERCÍCIO do dia - 25.1 -- <---/ INICIO --------------------------------------//
==============================

# Agora, a prática

> use erp;

# 1 Utilize uma combinação das expressões aritméticas e 'adicione' um campo chamado 'idade' à coleção 'clientes'.
- arredonde para baixo o valor da idade;
- calcule a idade usando a diferença entre a data corrente e a data de nascimento;
- 1 dia é igual a 86400000 milissegundos.
> db.clientes.aggregate([
  {
    $addFields: {
      idade: {
        $floor: {
          $divide: [
            { $subtract: ["$$NOW", "$dataNascimento"] },
            { $multiply: [86400000, 365] }
          ]
        }
      }  
    }
  },
]).pretty();
# resultado +
{
  "_id" : ObjectId("5e7bc243b642fc6050badb29"),
  "clienteId" : 23,
  "nome" : "DR. ALEXANDRE MONTEIRO",
  "dataNascimento" : ISODate("1987-01-14T12:51:00Z"),
  "sexo" : "FEMININO",
  "endereco" : {
    "logradouro" : "QUADRA DE FREITAS",
    "numero" : "943",
    "bairro" : "MALA E CUIA",
    "cidade" : "CARDOSO DO SUL",
    "uf" : "PR",
    "cep" : "28340274"
  },
  "idade" : 34
}

# 2 Utilizando o novo campo idade, conte quantos clientes têm entre 18 e 25 anos.
> db.clientes.aggregate([
  {
    $addFields: {
      idade: {
        $floor: {
          $divide: [
            { $subtract: ["$$NOW", "$dataNascimento"] },
            { $multiply: [86400000, 365] }
          ]
        }
      }
    }
  },
  {
    $match: {
      idade: {
        $gte: 18, $lte: 25
      }
    }
  },
  { $count: "clientes_entre18_25" }
]).pretty();
# resultado
{ "clientes_entre18_25" : 64 }

# 3 Remova os estágios $count e $match do exercício anterior e adicione um estágio no pipeline que coloque as compras do cliente no campo compras.
> db.clientes.aggregate([
  {
    $addFields: {
      idade: {
        $floor: {
          $divide: [
            { $subtract: ["$$NOW", "$dataNascimento"] },
            { $multiply: [86400000, 25] }
          ]
        }
      }
    }
  },
  {
    $lookup: {
      from: "vendas",
      localField: "clienteId",
      foreignField: "clienteId",
      as: "compras"
    }
  }
]).pretty();
# resultado +
{
  "_id" : ObjectId("5e7bc243b642fc6050badb29"),
  "clienteId" : 23,
  "nome" : "DR. ALEXANDRE MONTEIRO",
  "dataNascimento" : ISODate("1987-01-14T12:51:00Z"),
  "sexo" : "FEMININO",
  "endereco" : {
          "logradouro" : "QUADRA DE FREITAS",
          "numero" : "943",
          "bairro" : "MALA E CUIA",
          "cidade" : "CARDOSO DO SUL",
          "uf" : "PR",
          "cep" : "28340274"
  },
  "idade" : 505,
  "compras" : [
          {...}]}

# 4 Selecione TODOS os clientes que compraram entre Junho de 2019 e Março de 2020.
> db.clientes.aggregate([
  {
    $addFields: {
      idade: {
        $floor: {
          $divide: [
            { $subtract: ["$$NOW", "$dataNascimento"] },
            { $multiply: [86400000, 365] }
          ]
        }
      }
    }
  },
  {
    $lookup: {
      from: "vendas",
      localField: "clienteId",
      foreignField: "clienteId",
      as: "compras"
    }
  },
  {
    $match: {
      "compras.dataVenda": {
        $gte: ISODate("2019-06-01"),
        $lte: ISODate("2020-03-01"),
      }
    }
  },
]).pretty();
# resultado +
{
  "_id" : ObjectId("5e7bd299ad5e8ba212389599"),
  "clienteId" : 22,
  "dataVenda" : ISODate("2018-06-03T19:28:25Z"),
  "status" : "AGUARDANDO PAGAMENTO",
  "itens" : [
    {
      "produtoId" : 463,
      "nome" : "QUEIJO MOZARELA",
      "valorUnitario" : 43.43,
      "quantidade" : 24
    },
  ],
  "valorTotal" : 6087.01
},

# 5 Confira o número de documentos retornados pelo pipeline com o método itcount(). Até aqui, você deve ter 486 documentos sendo retornados.
> db.clientes.aggregate([
  {
    $addFields: {
      idade: {
        $floor: {
          $divide: [
            { $subtract: ["$$NOW", "$dataNascimento"] },
            { $multiply: [86400000, 365] }
          ]
        }
      }
    }
  },
  {
    $lookup: {
      from: "vendas",
      localField: "clienteId",
      foreignField: "clienteId",
      as: "compras"
    }
  },
  {
    $match: {
      "compras.dataVenda": {
        $gte: ISODate("2019-06-01"),
        $lte: ISODate("2020-03-31")
      }
    }
  },
]).itcount();
# resultado
486

# 6 Ainda nesse pipeline, descubra os 5 estados com mais compras.
> db.clientes.aggregate([
  {
    $addFields: {
      idade: {
        $floor: {
          $divide: [
            { $subtract: ["$$NOW", "$dataNascimento"] },
            { $divide: [86400000, 365] }
          ]
        }
      }
    }
  },
  {
    $lookup: {
      from: "vendas",
      localField: "clienteId",
      foreignField: "clienteId",
      as: "compras"
    }
  },
  {
    $match: {
      "compras.dataVenda": {
        $gte: ISODate("2019-06-01"),
        $lte: ISODate("2020-03-01")
      }
    }
  },
  {
    $addFields: {
      totalCompras: {
        $size: "$compras"
      }
    }
  },
  {
    $sort: { totalCompras: -1 }
  },
  { $limit: 10 },
  { $unwind: "$compras" },
  {
    $addFields: {
      "compras.valorComDesconto": {
        $subtract: [
          "$compras.valorTotal",
          { $multiply: ["$compras.valorTotal", 0.10] }
        ]
      }
    }
  },
  {
    $group: {
      _id: "$endereco.uf",
      totalCompras: {
        $sum: 1
      }
    }
  },
  {
    $sort: {
      totalCompras: -1
    }
  },
  { $limit: 5 }
]).pretty();
# resultado
{ "_id" : "MT", "totalCompras" : 37 }
{ "_id" : "AC", "totalCompras" : 37 }
{ "_id" : "RN", "totalCompras" : 19 }
{ "_id" : "RO", "totalCompras" : 19 }
{ "_id" : "PA", "totalCompras" : 19 }

# 7 Descubra o cliente que mais consumiu QUEIJO PRATO . Retorne um documento com a seguinte estrutura:
{
  "nomeCliente": "NOME",
  "uf": "UF DO CLIENTE",
  "totalConsumido": 100
}
> db.vendas.aggregate([
  {
    $match: {
      "itens.nome": "QUEIJO PRATO"
    }
  },
  {
    $unwind: "$itens"
  },
  {
    $match: {
      "itens.nome": "QUEIJO PRATO"
    }
  },
  {
    $group: {
      _id: "$clienteId",
      totalConsumido: {
        $sum: "$itens.quantidade"
      }
    }
  },
  {
    $sort: {
      totalConsumido: -1
    }
  },
  {
    $limit: 1
  },
  { // todos clientes
    $lookup: {
      from: "clientes",
      localField: "_id",
      foreignField: "clienteId",
      as: "cliente"
    }
  },
  {
    $unwind: "$cliente"
  },
  {
    $project: {
      nomeCliente: "$cliente.nome",
      uf: "$cliente.endereco.uf",
      totalConsumido: "$totalConsumido",
      _id: 0
    }
  }
]).pretty();
# resultado
{
  "nomeCliente": "SRTA. LETÍCIA DA MATA",
  "uf": "GO",
  "totalConsumido": 44
}

# 8 Selecione todas as vendas do mês de Março de 2020, com status EM SEPARACAO. Acrescente um campo chamado dataEntregaPrevista com valor igual a três dias após a data da venda. Retorne apenas os campos clienteId, dataVenda e dataEntregaPrevista.
> db.vendas.aggregate(
  {
    $match: {
      dataVenda: {
        $gte: ISODate("2020-03-01"),
        $lte: ISODate("2020-03-31")
      },
      status: "EM SEPARACAO"
    }
  },
  {
    $addFields: {
      dataEntregaPrevista: {
        $add: ["$dataVenda", 3 * 24 * 60 * 6000]
      }
    }
  },
  {
    $project: {
      _id: 0,
      clienteId: 1,
      dataVenda: 1,
      dataEntregaPrevista: 1
    }
  },
).pretty();
# resultado
{
  "clienteId" : 445,
  "dataVenda" : ISODate("2020-03-19T13:01:05Z"),
  "dataEntregaPrevista" : ISODate("2020-03-19T20:13:05Z")
}

Bônus
# 9 : Calcule a diferença absoluta em dias entre a data da primeira entrega prevista e a última, considerando o pipeline do exercício 8.
> db.vendas.aggregate([
  {
    $match: {
      dataVenda: {
        $gte: ISODate("2020-03-01"),
        $lte: ISODate("2020-03-31")
      },
      status: "EM SEPARACAO"
    }
  },
  {
    $addFields: {
      dataEntregaPrevista: {
        $add: ["$dataVenda", 3 * 24 * 60 * 60000]
      }
    }
  },
  {
    $project: {
      _id: 0,
      clienteId: 1,
      dataVenda: 1,
      dataEntregaPrevista: 1
    }
  },
  {
    $group: {
      _id: null,
      maxDataEntrega: {
        $max: "$dataEntregaPrevista"
      },
      minDataEntrega: {
        $min: "$dataEntregaPrevista"
      }
    }
  },
  {
    $project: {
      _id: 0,
      diasDiferenca: {
        $ceil: {
          $abs: {
            $divide: [
              {
                $subtract: [
                  "$maxDataEntrega",
                  "$minDataEntrega"
                ]
              },
              86400000
            ]
          }
        }
      }
    }
  },
]).pretty();
# resultado
{ "diasDiferenca" : 23 }

-- > EXERCÍCIO do dia - 25.1 -- <---/ FIM -----------------------------------------//
============================== Updates Complexos - Arrays - Parte 2