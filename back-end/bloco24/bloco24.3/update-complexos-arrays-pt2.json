############################## Updates Complexos - Arrays - Parte 2
-- > CONTEÚDO do dia - 24.3 -- <---/ INICIO --------------------------------------//

# Utilizar o operador $all para filtrar documentos;
# Utilizar o operador $elemMatch para filtrar documentos;
# Utilizar o operador $size para filtrar documentos pelo tamanho de arrays ;
# Utilizar o operador $expr para criar expressões de agregação;
# Utilizar expressões regulares e o operador $regex para buscar documentos;
# Utilizar o índice textual e o operador $text ;
# Utilizar o operador $mod.

// Operador $all
# equivalente ao operador $and, pois faz a comparação de todos os valores especificados, porém, para arrays.

# retorna somente os documentos em que o array tags seja exatamente igual ao passado como parâmetro no filtro
> db.inventory.find({ tags: ["camera", "accessories"] });
# retorna independentemente da existência de outros valores ou a ordem em que os elementos estejam.
> db.inventory.find({ tags: { $all: ["camera", "accessories"] } });

# Utilizar o '$all' poupa um pouco de código.
> db.inventory.find(
  { tags: { $all: ["electronics", "supplies"] } }
).pretty();
# retorno
{
  "_id" : 2,
  "item" : "cable",
  "tags" : ["electronics", "supplies", "camera", "accessories"]
}
// Se usar o $and :
> db.inventory.find(
  { $and: [{ tags: "electronics" }, { tags: "supplies" }] }
).pretty();

// Operador $elemMatch
# seleciona os documentos que contêm array com pelo menos 1 elemento que satisfaça todos os critérios de seleção especificados.

> use masterchef
> db.notas.insertMany([
  { _id: 1, nome: "Henrique", notas: [80, 76, 23, 67] },
  { _id: 2, nome: "Paola", notas: [99, 32, 56, 88] },
  { _id: 3, nome: "Erick", notas: [78, 81, 92, 20] },
  { _id: 4, nome: "Ana", notas: [76, 77, 78, 83] },
]);
{ "acknowledged" : true, "insertedIds" : [ 1, 2, 3, 4 ] }

# busca valores >= 80
> db.notas.find(
  { notas: { $elemMatch: { $gte: 80 } } }
).pretty();

# busca valores >= 10, < 30
> db.notas.find(
  { notas: { $elemMatch: { $gte: 10, $lt: 30 } } }
).pretty();

# busca valores >= 100 ()
> db.notas.find(
  { notas: { $elemMatch: { $gte: 100 } } }
).pretty();

> use survey
> db.survey.insertMany([
  {
    _id: 3,
    results: [
      { product: "abc", score: 10 },
      { product: "xyz", score: 5 }
    ]
  },
  {
    _id: 4,
    results: [
      { product: "abc", score: 8 },
      { product: "xyz", score: 7 }
    ]
  },
  {
    _id: 5,
    results: [
      { product: "abc", score: 7 },
      { product: "xyz", score: 8 }
    ]
  }
]);
{ "acknowledged" : true, "insertedIds" : [ 3, 4, 5 ] }
# resultado
> db.survey.find().pretty();

# seleciona os documentos em que o array 'results' contenha ao menos 1 elemento subdocumento com o campo 'product' = xyz e o campo 'score' >= a 8:
> db.survey.find(
  { results: { $elemMatch: { product: "xyz", score: { $gte: 8 } } } }
).pretty();

# resultado
{
  "_id" : 5,
  "results" : [
    { "product" : "abc", "score" : 7 },
    { "product" : "xyz", "score" : 8 }
  ]
}

# não precisa utilizar o operador $elemMatch se estiver utilizando uma condição para apenas "1" campo do documento embedado. 
> db.survey.find(
  { results: { $elemMatch: { product: "xyz" } } }
).pretty();

# a operação acima só tem uma condição, o $elemMatch não se faz necessário, pode utilizar a query abaixo:
> db.survey.find(
  { "results.product": "xyz" }
).pretty();

// Operador $size
# seleciona documentos em que um array contenha um número de elementos especificado.

> use products
> db.products.insertMany([
  { _id: 1, tags: ["red", "green"] },
  { _id: 2, tags: ["apple", "lime"] },
  { _id: 3, tags: "fruit" },
  { _id: 4, tags: ["orange", "lemon", "grapefruit"] }
]);
{ "acknowledged" : true, "insertedIds" : [ 1, 2, 3, 4 ] }

# apenas os documentos com o _id igual 1 e 2 serão retornados, pois seus campos tags são arrays e contêm exatamente 2 elementos:
> db.products.find({ tags: { $size: 2 } }).pretty();

# resultado
{ "_id" : 1, "tags" : [ "red", "green" ] }
{ "_id" : 2, "tags" : [ "apple", "lime" ] }

# o operador $size aceita apenas valores númericos, não sendo possível, trazer arrays com comprimento > 2 ($gt: 2).

// Operador $where
# pode ser utilizado para passar uma string contendo uma expressão ou função JavaScript.

# $where não será explorado porque, na versão 3.6 do MongoDB, um outro operador, $expr, que será visto a seguir, passou a suportar expressões de agregação.

// Operador $expr
# permite que você utilize expressões de agregação e construa queries que comparem campos no mesmo documento.

> use monthlyBudget;
> db.monthlyBudget.insertMany([
  { _id: 1, category: "food", budget: 400, spent: 450 },
  { _id: 2, category: "drinks", budget: 100, spent: 150 },
  { _id: 3, category: "clothes", budget: 100, spent: 50 },
  { _id: 4, category: "misc", budget: 500, spent: 300 },
  { _id: 5, category: "travel", budget: 200, spent: 650 }
]);
{ "acknowledged" : true, "insertedIds" : [ 1, 2, 3, 4, 5 ] }

# Busque os documentos em que o valor de spent exceda o valor de budget:
# $gt (>)
> db.monthlyBudget.find(
  { $expr: { $gt: ["$spent", "$budget"] } }
).pretty();
# resultado
{ "_id": 1, "category": "food", "budget": 400, "spent": 450 }
{ "_id": 2, "category": "drinks", "budget": 100, "spent": 150 }
{ "_id": 5, "category": "travel", "budget": 200, "spent": 650 }

# $expr entende que deve comparar os valores dos 2 campos. O $ é utilizado, indicando que a string entre aspas referencia um campo.

// Operador $regex
# fornece os "poderes" das expressões regulares para seleção de strings. MongoDB utiliza expressões regulares compatíveis com Perl(PCRE), versão 8.42, e com suporte a UTF-8.
> use products;
switched to db products
> show collections
products
> db.products.find().pretty();
> db.products.insertMany([
  { _id: 100, sku: "abc123", description: "Single line description." },
  { _id: 101, sku: "abc789", description: "First line\nSecond line" },
  { _id: 102, sku: "xyz456", description: "Many spaces before     line" },
  { _id: 103, sku: "xyz789", description: "Multiple\nline description" }
]);
{ "acknowledged" : true, "insertedIds" : [ 100, 101, 102, 103 ] }

# seleciona todos os documentos em que o campo sku "termine" com "789"
> db.products.find(
  { sku: { $regex: /789$/ } }
).pretty();
# resultado
{
  "_id": 103, "sku": "xyz789", "description": "Multiple\nline description"
}

# ignore letras maiúsculas ou minúsculas.
> db.products.find(
  { sku: { $regex: /^ABC/i } }
).pretty();
# resultado
{
  "_id": 100, "sku": "abc123", "description": "Single line description."
}
{ "_id" : 101, "sku" : "abc789", "description" : "First line\nSecond line" }
# O caractere 'i' ao lado da expressão indica a opção case-insensitive. Dessa forma, apenas os documentos que contenham ABC no campo sku serão retornados,

// Operador $text
# faz uma busca "textual" em um campo indexado por um text index.

$text tem a seguinte sintaxe:
{
  $text:
    {
      $search: <string>, // Com os termos que o MongoDB utilizará para fazer o parse e utilizará como filtro(OR)
      $language: <string>, // (Opcional) determina a lista de stop words(idioma) que será utilizada na tokenização da busca.
      $caseSensitive: <boolean>, // (Opcional) Recebe um valor booleano para habilitar ou desabilitar buscas case sensitive
      $diacriticSensitive: <boolean> // (Opcional) Recebe um valor booleano para habilitar ou desabilitar
    }
}

> db.articles.createIndex({ subject: "text" });
> db.articles.insertMany([
  { _id: 1, subject: "coffee", author: "xyz", views: 50 },
  { _id: 2, subject: "Coffee Shopping", author: "efg", views: 5 },
  { _id: 3, subject: "Baking a cake", author: "abc", views: 90  },
  { _id: 4, subject: "baking", author: "xyz", views: 100 },
  { _id: 5, subject: "Café Com Leite", author: "abc", views: 200 },
  { _id: 6, subject: "Сырники", author: "jkl", views: 80 },
  { _id: 7, subject: "coffee and cream", author: "efg", views: 10 },
  { _id: 8, subject: "Cafe com Leite", author: "xyz", views: 10 }
]);
{ "acknowledged": true, "insertedIds": [1, 2, 3, 4, 5, 6, 7, 8] }

# 1 Procurando um único termo
# utiliza os operadores $text e $search para buscar todos os documentos que contenham o termo coffee
> db.articles.find({ $text: { $search: "coffee" } }).pretty();
# resultado
{ "_id": 1, "subject": "coffee", "author": "xyz", "views": 50 }
{ "_id": 7, "subject": "coffee and cream", "author": "efg", "views": 10 }
{ "_id": 2, "subject": "Coffee Shopping", "author": "efg", "views": 5 }

# 2 Procurando qualquer um dos termos especificados
# procura por vários termos passando uma string delimitada por espaços. $text fará uma busca lógica(OR) por cada um desses termos.
> db.articles.find({ $text: { $search: "bake coffee cake" }}).pretty();
# resultado
{ "_id": 4, "subject": "baking", "author": "xyz", "views": 100 }
{ "_id": 3, "subject": "Baking a cake", "author" : "abc", "views": 90 }
{ "_id": 1, "subject": "coffee", "author": "xyz", "views": 50 }
{ "_id": 7, "subject": "coffee and cream", "author": "efg", "views": 10 }
{ "_id": 2, "subject": "Coffee Shopping", "author": "efg", "views": 5 }

# 3 Procurando por uma frase
# Procura pela frase "coffee shop"
> db.articles.find({ $text: { $search: "\"coffee shop\"" } }).pretty();
# resultado
{ "_id": 2, "subject": "Coffee Shopping", "author": "efg", "views": 5 }

// Operador $mod
# seleciona todos os documentos em que o valor do campo dividido por um divisor seja igual ao valor especificado
# encontra o resto da divisão.
> use inventory
> db.inventory.insertMany([
  { _id: 3, item: "abc123", qty: 0 },
  { _id: 4, item: "xyz123", qty: 5 },
  { _id: 5, item: "ijk123", qty: 12 }
]);
{ "acknowledged" : true, "insertedIds" : [ 3, 4, 5 ] }

# seleciona todos os documentos da coleção em que o valor do campo qty módulo 4 seja 0
> db.inventory.find({ qty: { $mod: [4, 0] } });
# resultado
{ "_id": 3, "item": "abc123", "qty": 0 }
{ "_id": 5, "item": "ijk123", "qty": 12 }

-- > CONTEÚDO do dia - 24.3 -- <---/ FIM -----------------------------------------//
##############################
-- > AULA ao VIVO - 24.3 ----- <---/ INICIO --------------------------------------//

#### O QUE VAMOS FALAR
- $all
- $elemenMatch
- $size
- $expr
- $regex
- $text
- $mod

---
### $all
```js
db.collection.find({ field: { $all: ["item1", "item2", "Item3"] } });
```
---
### $elemenMatch
```js
db.collection.find({
  field: { $elemMatch: { listField: { $gte: 200 } } },
});
```
---
### $size
---
### $expr
```js
db.collection.find({ $expr: { $gt: ["$field1", "$field2"] } });
```
---
![Regex]
---
### $text
![Text]
---
### $mod
```js
db.inventory.find({ qty: { $mod: [4, 0] } });
// qty % 4 = 0
```
---

-- > AULA ao VIVO - 24.3 ----- <---/ FIM -----------------------------------------//
##############################
-- > EXERCÍCIO do dia - 24.3 -- <---/ INICIO --------------------------------------//

# Agora, a prática!
# dataset de filmes

> db.movies.drop();
> db.movies.insertMany([
  {
    title: "Batman",
    category: ["action", "adventure"],
    imdbRating: 7.7,
    budget: 35
  },
  {
    title: "Godzilla",
    category: ["action", "adventure", "sci-fi"],
    imdbRating: 6.6,
    budget: 10
  },
  {
    title: "Home Alone",
    category: ["family", "comedy"],
    imdbRating: 7.4
  }
]);
"acknowledged" : true,

# 1 Utilizando o operador $all, retorne todos os filmes que contenham action e adventure no array category.
> db.movies.find(
  { category: { $all: ["action","adventure"] } }
).pretty();
# resultado
{
  "_id" : ObjectId("611b8a26b32b59c18bef776e"),
  "title" : "Batman",
  "category" : ["action", "adventure"],
  "imdbRating" : 7.7,
  "budget" : 35
},
{
  "_id" : ObjectId("611b8a26b32b59c18bef776f"),
  "title" : "Godzilla",
  "category" : ["action", "adventure", "sci-fi"],
  "imdbRating" : 6.6,
  "budget" : 10
}

# 2 Agora retorne os filmes que contenham action no array category e possuem nota do IMDB maior do que 7.
> db.movies.find(
  { 
    category: { $all: ["action"] }, imdbRating: { $gt: 7 }
  }
).pretty();
# resultado
{
  "_id" : ObjectId("611b8a26b32b59c18bef776e"),
  "title" : "Batman",
  "category" : ["action", "adventure"],
  "imdbRating" : 7.7,
  "budget" : 35
}

# 3 Adicione um array chamado ratings ao filme Batman com os seguintes valores: [85, 100, 102, 105]. Dica: lembre-se do operador $each visto no dia anterio.
> db.movies.updateOne(
  { title: "Batman" },
  { $push: { ratings: { $each: [85, 100, 102, 105] } } }
);
# resultado
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

# 4 Adicione um array chamado ratings ao filme Godzilla com os seguintes valores: [78, 52, 95, 102].
> db.movies.updateOne(
  { title: "Godzilla" },
  { $push: { ratings: { $each: [78, 52, 95, 102] } } }
);
# resultado
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

# 5 Adicione um array chamado ratings ao filme Home Alone com os seguintes valores: [200, 99, 65].
> db.movies.updateOne(
  { title: "Home Alone" },
  { $push: { ratings: { $each: [200, 99, 65] } } }
);
# resultado
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

# 6 Retorne todos os filmes com ratings maior do que 103, exibindo apenas os campos title e ratings.
> db.movies.find(
  { ratings: { $elemMatch: { $gt: 103 } } },
  { title: 1, ratings: 1, _id: 0 }
).pretty();
# resultado
{
  "title": "Batman",
  "ratings": [85, 100, 102, 105]
}
{ "title": "Home Alone", "ratings": [200, 99, 65] }

# 7 Retorne todos os filmes com ratings entre 100 e 105, exibindo apenas os campos title e ratings.
# $gte (>=), $lte (<=)
> db.movies.find(
  { ratings: { $elemMatch: { $gte: 100, $lte: 105 } } },
  { title: 1, ratings: 1, _id: 0 }
).pretty();
# resultado
{ "title": "Batman", "ratings": [85, 100, 102, 105] }
{ "title": "Godzilla", "ratings": [ 78, 52, 95, 102 ] }

# 8 Retorne todos os filmes com ratings entre 64 e 105 e divisíveis por 9, exibindo apenas os campos title e ratings.
# $mod(resto da divisão)
> db.movies.find(
  { ratings: { $elemMatch: { $gte: 64, $lte: 105, $mod: [9, 0] } } },
  { title: 1, ratings: 1, _id: 0 }
).pretty();
# resultado
{ "title" : "Home Alone", "ratings" : [ 200, 99, 65 ] }

# 9 Retorne os filmes da categoria adventure e com ratings maior do que 103, exibindo apenas os campos title, ratings e category.
# $all(faz a comparação)
> db.movies.find(
  {
    category: { $all: ["adventure"] },
    ratings: { $elemMatch: { $gte: 103 } }
  },
  { title: 1, ratings: 1, category: 1, _id: 0 }
).pretty();
# resultado
{
  "title" : "Batman",
  "category" : ["action", "adventure"],
  "ratings" : [85, 100, 102, 105]
}

# 10 Retorne somente o título de todos os filmes com dois elementos no array category.
# $size(número de elementos)
> db.movies.find(
  { category: { $size: 2 } },
  { title: 1, _id: 0 }
).pretty();
# resultado
{ "title" : "Batman" }
{ "title" : "Home Alone" }

# 11 Retorne somente o título de todos os filmes com quatro elementos no array ratings.
> db.movies.find(
  { ratings: { $size: 4 } },
  { title: 1, ratings: 1, _id: 0 }
).pretty();
# resultado
{ "title" : "Godzilla", "ratings" : [ 78, 52, 95, 102 ] }

# 12 Busque os filmes em que o módulo 5 do campo budget seja 0 e que o array category tenha tamanho 2.
> db.movies.find(
  {
    budget: { $mod: [5, 0] },
    category: { $size: 2 }
  }
).pretty();
# resultado
{
  "_id" : ObjectId("611b8a26b32b59c18bef776e"),
  "title" : "Batman",
  "category" : ["action", "adventure"],
  "imdbRating" : 7.7,
  "budget" : 35,
  "ratings" : [85, 100, 102, 105]
}

# 13 Retorne os filmes da categoria "sci-fi" ou que possua o ratings maior do que 199, exibindo apenas os campos title, ratings e category.
> db.movies.find(
  {
    $or: [
      { category: { $all: ["sci-fi"] } },
      { ratings: { $elemMatch: { $gt: 199 } } }
    ]
  },
  { title: 1, ratings: 1, category: 1, _id: 0 }
).pretty();
# resultado
{
  "title" : "Godzilla",
  "category" : ["action", "adventure", "sci-fi"],
  "ratings" : [78, 52, 95, 102]
}
{
  "title" : "Home Alone",
  "category" : ["family", "comedy"],
  "ratings" : [200, 99, 65]
}

# 14 Retorne os filmes em que o ratings possua tamanho 4 e que seja da category "adventure" ou "family", mas que não tenha o imdbRating menor que 7.
> db.movies.find(
  { $and: [
    { ratings: { $size: 4 } },
    { category: { $in: ["adventure", "family"] } },
    { imdbRating: { $not: { $lt: 7 } } }
  ] }
).pretty();
# resultado
--

# 15 Adicione o campo description no filme Batman com o seguinte valor: "The Dark Knight of Gotham City begins his war on crime with his first major enemy being Jack Napier, a criminal who becomes the clownishly homicidal Joker.".
> db.movies.updateOne(
  { title: "Batman" },
  { $set: { description: "The Dark Knight of Gotham City begins his war on crime with his first major enemy being Jack Napier, a criminal who becomes the clownishly homicidal Joker." } }
);
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

# 16 Adicione o campo description no filme Godzilla com o seguinte valor: "The world is beset by the appearance of monstrous creatures, but one of them may be the only one who can save humanity.".
> db.movies.updateOne(
  { title: "Godzilla" },
  { $set: { description: "The world is beset by the appearance of monstrous creatures, but one of them may be the only one who can save humanity." } }
);
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

# 17 Adicione o campo description no filme Home Alone com o seguinte valor: "An eight-year-old troublemaker must protect his house from a pair of burglars when he is accidentally left home alone by his family during Christmas vacation.".
> db.movies.updateOne(
  { title: "Home Alone" },
  { $set: { description: "An eight-year-old troublemaker must protect his house from a pair of burglars when he is accidentally left home alone by his family during Christmas vacation." } }
);
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

# 18 Utilizando o operador $regex, retorne todos os filmes em que a descrição comece com a palavra "The".
> db.movies.find(
  { description: { $regex: /^The/ } }
).pretty();
# resultado
> "Godzilla"

# 19 Utilizando o operador $regex, retorne todos os filmes em que a descrição termine com a palavra "humanity.".
> db.movies.find(
  { description: { $regex: /humanity.$/ } }
).pretty();
# reultado
> "Godzilla"

# 20 Crie um índice do tipo text no campo description.
> db.movies.createIndex({ description: "text" });
# resultado
{
  "numIndexesBefore": 1,
  "numIndexesAfter": 2,
  "createdCollectionAutomatically": false,
  "ok": 1
}

# 21 Utilizando o operador $text, busque por filmes que contenham o termo "vacation".
> db.movies.find(
  { $text: { $search: "vacation" } }
).pretty();
# resultado
> "Home Alone"

# 22 Utilizando o operador $text, busque por filmes que contenham os termos "monstrous" ou "criminal".
> db.movies.find(
  { $text: { $search: "monstrous criminal" } }
).pretty();
# resultado
> "Godzilla"

# 23 Utilizando o operador $text, busque por filmes que contenham a frase "when he is accidentally".
> db.movies.find(
  { $text: { $search: "\"when he is accidentally\"" } }
).pretty();
# resultado
> "Home Alone"

-- > EXERCÍCIO do dia - 24.3 -- <---/ FIM -----------------------------------------//
############################## Updates Complexos - Arrays - Parte 2
